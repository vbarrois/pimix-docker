(()=>{"use strict";var e={147:e=>{e.exports=JSON.parse('{"name":"pimix-data","version":"1.0.8","description":"Pimix REST API from data management","main":"index.js","scripts":{"scanner":"nodemon ./dist/scanner.js","data":"nodemon ./dist/rest.js","wifi":"nodemon ./dist/wifi.js","test":"echo \\"Error: no test specified\\" && exit 1","lint":"eslint \\"src/**/*.js\\" --ignore-pattern node_modules/ ","build":"rm -rf dist && webpack","start":"yarn concurrently -k -n \\"data,scanner,wifi\\" -p \\"[{name}]\\" -c \\"yellow,green,blue\\" \\"yarn data\\" \\"yarn scanner\\" \\"yarn wifi\\""},"repository":{"type":"git","url":"git+https://github.com/vbarrois/pimix-data.git"},"author":"Vincent Barrois","license":"ISC","bugs":{"url":"https://github.com/vbarrois/pimix-data/issues"},"homepage":"https://github.com/vbarrois/pimix-data#readme","dependencies":{"@babel/core":"^7.9.6","@babel/preset-env":"^7.9.6","babel-loader":"^8.1.0","bcryptjs":"^2.4.3","bull":"^3.11.0","child_process":"^1.0.2","chokidar":"^3.5.3","concurrently":"^5.1.0","copy-webpack-plugin":"^6.1.1","eslint":"^6.6.0","eslint-config-standard":"^14.1.0","eslint-loader":"^4.0.2","eslint-plugin-import":"^2.18.2","eslint-plugin-node":"^10.0.0","eslint-plugin-promise":"^4.2.1","eslint-plugin-standard":"^4.0.1","express":"^4.17.1","getmac":"^5.16.0","jimp":"^0.10.0","jsonwebtoken":"^8.5.1","moment":"^2.24.0","music-metadata":"^7.13.3","nodemon":"^1.19.4","sequelize":"^5.21.1","sequelize-cli":"^6.6.0","socket.io-client":"^4.4.1","spotify-web-api-node":"^4.0.0","sqlite3":"^5.0.8","uuid":"^9.0.0","webpack":"^5.75.0","webpack-cli":"^5.0.1","webpack-dev-middleware":"^6.0.1","webpack-hot-middleware":"^2.25.3","webpack-node-externals":"^3.0.0"}}')}},n={};function o(t){var s=n[t];if(void 0!==s)return s.exports;var i=n[t]={exports:{}};return e[t](i,i.exports,o),i.exports}o.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return o.d(n,{a:n}),n},o.d=(e,n)=>{for(var t in n)o.o(n,t)&&!o.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},o.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{const e=require("socket.io-client");var n=o.n(e);const t=require("getmac");var s=o.n(t);const i=require("lodash");var r=o.n(i);const c=require("os");var a=o.n(c);const l=require("node-wifi");var _=o.n(l);const d=e=>new Promise(((n,o)=>{setTimeout((()=>{_().scan().then(n).catch(o)}),e),e>0&&console.log("... waiting for "+e+"ms")})),m=o(147);console.clear(),console.log("__________.__        .__          __      __.______________.___ "),console.log("\\______   \\__| _____ |__|__  ___ /  \\    /  \\   \\_   _____/|   |"),console.log(" |     ___/  |/     \\|  \\  \\/  / \\   \\/\\/   /   ||    __)  |   |"),console.log(" |    |   |  |  Y Y  \\  |>    <   \\        /|   ||     \\   |   |"),console.log(" |____|   |__|__|_|  /__/__/\\_ \\   \\__/\\  / |___|\\___  /   |___|"),console.log("                   \\/         \\/        \\/           \\/         v"+m.version);const g=process.env.PIMIX_ROUTER||"127.0.0.1:82",p="http://"+g;let u=0,h=!1,w=!1;const f=process.env.WAN_NIC||"wlan0";console.log("> WAN interface used: "+f);const b=process.env.LAN_NIC||"enp3s0";console.log("> LAN interface used: "+b);for(const e in a().networkInterfaces())if(e===b){const o=s()(e);console.log("> Binding network interface "+b+" with MAC="+o),console.log("> Waiting for router connection..."),w=!0;const t=n().connect(p,{query:'binding={ "component": "wifiscanner", "ID": "'+o+'" }'});t.on("connect",(()=>{var e;console.log("> Connected to router: "+g),h=!0,(e=f,new Promise(((n,o)=>{_().init({iface:e}),n()}))).then((()=>{v(t,!0)})).catch((e=>{console.log(e.toString())}))})),t.on("disconnect",(()=>{console.log("> Router connection lost."),h=!1})),t.on("command",(e=>{const n=e;switch(n.action){case"rescan":v(t,!0);break;case"refresh":v(t);break;case"down":y(t);break;case"up":k(t,n.ssid,n.password)}}))}w||console.log("unable to find NIC interface "+b+", quit.");const v=(e,n=!1)=>{x(f,n).then((n=>{e.emit("scan",JSON.stringify(n))})).catch((o=>{u++,h&&(console.log("> Error - NIC "+f+" locked, retry in 5000ms"),e.emit("message",o),u<3&&setTimeout((()=>{v(e,n)}),5e3))}))},y=e=>{new Promise(((e,n)=>{_().disconnect().then(e).catch(n)})).then((()=>(e.emit("message",{referer:"wifi",severity:1,message:"Disconnected"}),x(f,!1)))).then((n=>{e.emit("scan",JSON.stringify(n))})).catch((n=>{e.emit("message",n)}))},k=(e,n,o)=>{((e,n)=>new Promise(((o,t)=>{_().connect({ssid:e,password:n}).then(o).catch(t)})))(n,o).then((()=>(e.emit("message",{referer:"wifi",severity:1,message:"Connected to "+n}),x(f,!1)))).then((n=>{e.emit("scan",JSON.stringify(n))})).catch((o=>{console.log(o.toStirng()),e.emit("message",{referer:"wifi",severity:8,message:"Cannot connect to "+n})}))},x=(e,n)=>new Promise(((o,t)=>{const s={connected:!0,interface:f,ssid:"",networks:[]};((e,n,o=3e3)=>new Promise(((t,s)=>{const i=[];console.log("> WIFI "+(n?"deep ":"")+"scan"),n&&i.push((e=>new Promise(((n,o)=>{_().rescan(e).then(n()).catch(o)})))(e)),Promise.all(i).then((()=>d((n?1:0)*o))).then(t).catch(s)})))(e,n,3e3).then((e=>(s.networks=e,console.log("> "+e.length+" networks found"),new Promise(((e,n)=>{_().getCurrentConnections().then(e).catch(n)}))))).then((e=>{!r().isNil(e)&&e.length>0&&(s.ssid=e[0].ssid),console.log("> WIFI search for connected network ("+s.ssid+")"),o(s)})).catch((e=>{const n={referer:"wifi",severity:8,message:e.toString()};t(n)}))}))})()})();